---
title: draft
published: true
---

http://www.mehdi-khalili.com/orm-anti-patterns-series


# Chapter 1 : Back to School

## Relational database 101
Database ถือเป็นหัวใจสำคัญขอบการสร้าง application จุดประสงค์หลักของ database ก็ตรงตัวตามชื่อของมัน คือเป็นฐานข้อมูล ทุกๆ application จะมีการเก็บข้อมูลอย่างใด อย่างหนึ่งเสมอ Relational database ก็เป็นหนึ่งในรูปแบบการเก็บข้อมูลที่ว่านั้น และตรงตามชื่อของมัน คือฐานข้อมูลเชิงสัมพันธ์

Doctrine ออกแบบมาเพื่อทำงานกับฐานข้อมูลหลายแบบ รวมทั้ง Relational Database ด้วย เมื่อทำงานกับ Doctrine เราแทบไม่ต้องแตะต้อง Database เลย สำหรับ Doctrine แล้ว Database ถูกมองเป็น Storage หรือพื้นที่สำหรับเก็บข้อมูลอย่างหนึ่ง แต่เพื่อให้ง่ายต่อการทำความเข้าใจการทำงานของ Doctrine เราควรรู้พื้นฐานของ Database แต่ละชนิดด้วย

Relational Database ถูกออกแบบมาเพื่อจัดการกับข้อมูลขนาดใหญ่ ความสามารถที่เด่นชัดของมันคือ ช่วยลดความซ้ำซ้อนของการจัดเก็บข้อมูลได้อย่างยอดเยี่ยม (แต่มันก็นำความปวดหัวมาสู่เราเหมือนกัน เมื่อต้องดึงข้อมูลที่ไม่ซ้ำซ้อนนั้นออกมาแสดง) ต้องยกนิ้วให้กับคนที่นำเสนอไอเดียนี้จริงๆ (1970, Edgar F. Codd) เพราะมันดูเรียบง่าย แต่เปี่ยมพลังมาก

### Foundational
พื้นฐานแนวคิดของ Relational Database ค่อนข้างเรียบง่าย เราแค่ต้องเรียนรู้เรื่องง่ายๆ 3 เรื่อง นั่นคือ

    1. **Column** คือ set ของข้อมูล (data) ที่เราต้องการเก็บ แบ่งออกเป็นหลายประเภท ตามชนิดข้อมูลทางคอมพิวเตอร์ เช่น String -- ชื่อคน, Integer -- อายุ เป็นต้น
    2. **Row** คือ Record หรือแถวข้อมูลที่ประกอบไปด้วยชุดข้อมูลของ Column
    3. **Table** คือ Collection หรือกลุ่มข้อมูลที่ประกอบไปด้วย Row ต่างๆ


เมื่ออธิบายด้วยภาพ เราจะได้รูปแบบนี้
![enter image description here](https://i.imgur.com/BmV1L1L.png)

การจัดเก็บข้อมูลก็เพียงแต่กำหนด Column ที่เราต้องการ และเก็บลงมาเรื่อยๆ ทีละ Row ตามแต่เราจะพอใจ หน้าตามันจะเหมือนกับ Excel Sheet ที่เราคุ้นเคย

---- TODO: ใส่ภาพตัวอย่างตารางข้อมูล

และนี่คือพื้นฐานการจัดเก็บข้อมูลสำหรับ Relational Database

### Relational
ความสัมพันธ์ ถือเป็นหัวใจสำคัญของ Relational Database เพราะเมื่อเก็บข้อมูลกันจริงๆ Relational Database จะแยกเก็บข้อมูลแต่ละอย่างออกจากกัน คือแยก table ออกจากกันเป็นเรื่องๆ เช่น คน, ประเทศ จะถูกจัดเก็บกันคนละ table ทั้งนี้เพื่อลดความซ้ำซ้อนของการจัดเก็บข้อมูลนั่นเอง

เทคนิกในการแยกประเภทข้อมูลเพื่อไม่ให้เกิดความซ้ำซ้อนใน Relational Database เรียกว่า Normalization แบ่งออกเป็น 5 ระดับ (1NF - 5NF) ในทางปฏิบัติเราใช้เทคนิกนี้เพียง 1NF - 3NF ก็พอสำหรับ application ทั่วๆ ไป

เรื่อง Normalization ถือเป็นเรื่องสำคัญที่เราต้องรู้ ถ้าหากเราต้องการเขียน app ขึ้นมาจริงๆ ซักตัว แต่เราจะว่ากันในหัวข้อถัดไปนะครับ

เอาล่ะครับ เมื่อข้อมูลไม่ซ้ำซ้อนกัน การอัปเดทข้อมูลของเราก็จะง่ายตามไปด้วย ลองนึกภาพว่า เรามีข้อมูลคน 100 คนใน 10 ประเทศ แปลว่าทุกๆ 10 คน จะเป็นคนประเทศเดียวกัน

ถ้าหากเราเก็บข้อมูลทั้งหมดไว้ใน table เดียวกัน และถ้าเขียนชื่อประเทศผิดซักประเทศ เราอาจต้องตามแก้ข้อมูลถึง 10 rows ก็เป็นได้

---- TODO: insert data sample

ทางออกคือแยกเก็บคน และเก็บประเทศออกจากกัน และทำการ link เข้าหากันด้วย key ตามวิธีของ Normalization

---- TODO: insert data sample

ถึงตรงนี้ มีสิ่งที่เราต้องเรียนรู้เพิ่มอีก 3 อย่าง เพื่อใช้ออกแบบ database ของเราให้มีความสัมพันธ์กัน

#### 1. Primary Key
คือ ค่าของข้อมูลใน column ที่ใช้กำหนดความเป็นหนึ่งเดียว (uniquely) ของแต่ละแถวข้อมูล คล้ายกับหมายเลขบัตรประชาชน ที่แต่ละคนจะมีไม่ซ้ำกัน

Primary Key อาจเป็นค่าของ column เดียว หรือหลาย column รวมกัน ก็ได้ และถ้ามันมาจากหลาย column รวมกัน เราจะเรียกมันว่า `Composite Key` หรือคีย์ร่วม

--- TODO: insert data sample

Composite Key คือการใช้ค่าของหลาย column รวมกัน เพื่อให้เกิดความเป็นหนึ่งเดียว (uniquely) ของแถวข้อมูล เช่น หากเราไม่ใช้บัตรประชาชนเป็นตัวกำหนดความเป็นหนึ่งเดียวของคน เราอาจใช้ ชื่อ และนามสกุล เป็นตัวกำหนดก็ได้ (แต่ในความเป็นจริงชื่อและนามสกุลอาจซ้ำกันได้)

--- TODO: insert data sample

ในระบบสมัยใหม่ ไม่นิยมใช้ Composite Key เพื่อเป็นตัวแทนของข้อมูลจำเพาะมากนัก โดยส่วนมากจะใช้เพื่อเชื่อมเข้ามูลใน direction ที่เรียก่า many-to-many 

Primary Key นิยมใช้ ตัวเลขลำดับ 1-n เป็นส่วนมาก เนื่องจากมีความสะดวก และไม่จำเป็นต้องเป็นที่จดจำของคน แต่หากเราต้องการ Key ที่มีความหมายและง่ายสำหรับการจดจำ หรือในทางกลับกันคือ ยากสำหรับการคาดเดา เราก็อาจสร้างชุดรหัสที่ไม่ซ้ำกันมาเป็น primary key แทนก็ได้

#### 2. Foreign Key
Foreign Key ก็คือ Primary Key ที่ถูกใช้ในการอ้างอิงถึงแถวข้อมูล (row) ในต่าง table เมื่อเราทำการ link หรือทำความสัมพันธ์ของข้อมูล

--- TODO: insert data sample

#### 3. Cardinality
Cardinality คือลักษณะเฉพาะของสัมพันธ์ในระบบ RDB ส่วนนี้สำคัญมากในการทำความเข้าใจวิธีคิดของ  Doctrine เราจะได้เรียนรู้ Direction ต่างๆ ของสัมพันธ์ของข้อมูลตลอดทั้งเล่มของหนังสือนี้

อย่างที่เราทราบ RDB ใช้ระบบ Key เป็นตัวอ้างอิงเพื่อสร้างความสัมพันธ์ของข้อมูลในรูปแบบต่างๆ Primary Key ใช้เป็นตัวแทนของแต่ละ Row และเมื่อมันถูกใช้เป็นตัวอ้างอิงใน table อื่น เราจะเรียกมันว่า Foreign Key โดยพื้นฐานแล้วลักษณะความสัมพันธ์ใน RDB แบ่งออกเป็น 3(+1) แบบคือ

##### ***One-to-One** ความสัมพันธ์แบบ หนึ่งต่อหนึ่ง (1:1)*

![enter image description here](https://i.imgur.com/K24nHV0.png)

ความสัมพันธ์ของข้อมูลแบบหนึ่งต่อหนึ่ง เช่น **"ประเทศ 1 ประเทศ มีเมืองหลวงเพียงแห่งเดียว ในทางกลับกัน เมืองหลวง 1 เมือง ก็เป็นของประเทศได้เพียงประเทศเดียว"**

ในทางปฏิบัติสถานการณ์ที่เข้าลักษณะ one-to-one แบบสมจริงนั้นมีไม่มากนัก แต่ one-to-one ก็มีประโยชน์ในลักษณะของการใช้เชื่อมข้อมูลที่เป็นตัวเลือก (Optional) ของระบบ หรือการเพิ่มคุณสมบัติของระบบในภายหลัง (อาจถอดเข้าถอดออกได้) เช่น การเก็บข้อมูลเฉพาะด้านของพนักงานแต่ละคน เราอาจไม่ต้องรวมทุกอย่างไว้ในตารางของ "พนักงาน - employee" ก็ได้ เราสามารถแยกกลุ่มข้อมูลออกเป็นส่วนๆ และเชื่อมความสัมพันธ์กันแบบ one-to-one เช่น ข้อมูลสุขภาพ (employee-medical), ข้อมูลภูมิลำนำ (employee-local) เป็นต้น

##### ***One-to-Many** หรือ หนึ่งต่อมาก (1:n) ....*
##### ***Many-to-Many** หรือ มากต่อมาก (n:n)*

![enter image description here](https://i.imgur.com/NVux8Bf.png)

![enter image description here](https://i.imgur.com/0l5YFkP.jpg)

##### ***Many-to-One** หรือ มากต่อหนึ่ง (n:1) ....* inverse of 1:n

### Normalization
https://www.guru99.com/database-normalization.html

### ER Modeling
https://www.guru99.com/er-modeling.html

## SQL 101

จากหัวข้อที่ผ่านมาเราได้เรียนรู้เกี่ยวกับวิธีคิดในการเก็บข้อมูลของ RDB หัวข้อนี้เราจะได้เรียนรู้วิธีการบริหารจัดการข้อมูลใน RDB ในที่นี้เราจะเรียนรู้เพียงการบริหารจัดการข้อมูลแบบเบื้องต้นคือ

  - Read การดูข้อมูลในรูปแบบต่าง
  - Create การเพิ่มรายการใหม่
  - Update การแก้ไขข้อมูลเดิม
  - Delete การลบข้อมูลทิ้ง

การบริหารจัดการข้อมูลใน RDB โดยพื้นฐานใช้ภาษาคอมพิวเตอร์ง่ายๆ ที่เรียกว่า SQL (Structured Query Language) เป็นภาษาโคลงสร้างที่ไม่ซับซ้อน ไม่เน้นการคำนวณ (Calculate logic) ในตัวภาษาเอง เป็นเพียงประโยคคำสั่งที่ตรงไปตรงมา ทำให้มันง่ายต่อการจดจำ และการใช้งานมากๆ

### How Is Data Organized in a Relational Database?
เพื่อให้ใช้ SQL ได้เร็วขึ้น เราลองมาดูรูปแบบการเก็บข้อมูลใน RDB กันก่อน ดังที่เราได้เรียนรู้มาแล้วว่า RDB เก็บข้อมูลในรูปแบบ "ตาราง" ซึ่งอันที่จริงในทางคอมพิวเตอร์มันคือการเก็บข้อมูลในรูปแบบ "two-dimensional array" หรือทางคณิตศาสตร์ คือ "two-dimensional matrix" เรียกง่ายๆ ง่า "อาเรย์สองมิติ"

#### Two-dimensional Matrix

![two-dimensional matrix](https://i.imgur.com/zDTfyKV.gif)

นี่คือรูปแบบ Matrix 2 มิติ ดูไม่ซับซ้อนเลยใช่ไหมครับ อธิบายง่ายๆ คือ ในแต่ละวงเว็บ ตัวเลขแรกคือลำดับของแถวข้อมูล ตัวเลขที่สองคือลำดับคอลัมน์ -- (row, column) แค่นี้เองครับ

#### Two-dimensional Arrays in C-based
ส่วนในระบบคอมพิวเตอร์ Array 2 มิติในภาษาคอมพิวเตอร์ที่มีพื้นมาจากภาษาซี (C-based) มีรูปแบบดังนี้

![enter image description here](https://i.imgur.com/5kCifUW.jpg)

ดูแล้วก็ไม่มีอะไรซับซ้อนเกินไปใช่ไหมครับ เพียงแค่ภาษา C-based จะนับลำดับเริ่มต้นของ array จาก `0-n` 

สิ่งที่เราต้องเรียนรู้ต่อไปก็ไม่ใช่เรื่องยากแล้ว มันไม่ใช่เกมส์ไล่จับหนูที่ไม่มีทิศทาง การเข้าถึงตำแหน่งของข้อมูลใน RDB ค่อนข้างตรงไปตรงมา มันก็แค่ ***"คอลัมน์ไหน แถวที่เท่าไหร่?"*** หรือ ***"แถวที่คอลัมน์มีค่าเท่ากับ x"***  แค่นั้นเอง!

### Example Data
ทีนี้เรามาลองบริหารจัดการข้อมูลในระบบ RDB กันดูเลยดีกว่านะครับ และเพื่อให้เห็นภาพชัดขึ้น ผมจะจำลองข้อมูลง่ายๆ ขึ้นมา เอาเป็นชื่อว่า *"การบริหารจัดการ**ผู้ใช้งาน**และ**กลุ่ม**"* นะครับ

#### ER Modeling

![enter image description here](https://i.imgur.com/uP6tXmQ.png)

โมเดลตัวอย่างของเรามีแค่ 2 ตาราง และมีควาสัมพันธ์กันอยู่ในแบบ **One-to-many (1:M)** หรือาจจะพูดได้ว่า

	- **1:M** ถ้ามองจากมุมของ **user -> group** คือ *"ผู้ใช้ 1 คนอยู่ในกลุ่มได้ 1 กลุ่ม"*
	- **M:1** ถ้ามองจากมุมมองของ **group -> user** คือ *"มีผู้ใช้หลายคน (หรืออาจจะไม่มี) อยู่ในแต่ละกลุ่ม"*

#### ER Data Dictionary
##### - Group : กลุ่มผู้ใช้งาน

| Column 	| Type    	| Key 	| Note        	|
|--------	|---------	|-----	|-------------	|
| id     	| INT     	| PK  	| Primary Key 	|
| name   	| VARCHAR 	|     	| ชื่อกลุ่มผู้ใช้    	|


##### - User : ผู้ใช้งาน

| Column     	| Type     	| Key 	| Note                  	|
|------------	|----------	|-----	|-----------------------	|
| id         	| INT      	| PK  	| Primary Key           	|
| group_id   	| INT      	| FK  	| Foreign Key ของ group 	|
| username   	| VARCHAR  	|     	| ชื่อผู้ใช้งาน              	|
| password   	| VARCHAR  	|     	| รหัสผ่าน                	|
| email      	| VARCHAR  	|     	| อีเมล์                  	|
| created_at 	| DATETIME 	|     	| วันที่เพิ่มรายการ          	|


### Basic SQL

#### Select
#### Insert
#### Update
#### Delete
#### Union
#### Join
#### Condition
#### Where
#### Having
#### Group
#### Order
#### Limit
#### Join-Conditional
#### Sub Query

## ORM 101

# Chapter 2 : Basic ORM

## Simple Forum Software

ก่อนจะเข้าเนื้อหาของ Doctrine น่าจะเป็นเรื่องที่ดีมาก ถ้าเราจะมาลองเคาะสนิมกันด้วยบทเรียนเก่าๆ เพื่อให้เห็นวิธีการและวิธีคิดที่ต่างกัน ลองมาทำระบบเว็บบอร์ดหรือ forum ง่ายๆ กันดูนะครับ

เราจะใช้ความรู้และเทคนิกจากบทที่แล้ว สำหรับสร้างเว็บบอร์ดนี้ขึ้นมา ก่อนอื่น เรามากำหนด feature คร่าวๆ กันก่อนครับ

### Features
  - [ ] ผู้ใช้ (User) ตั้งกระทู้ถามปัญหา (Topic) ได้ไม่จำกัด
  - [ ] ผู้ตั้งกระทู้สามารถเลือกความเห็น (Comment) 1 ความเห็นว่าเป็นคำตอบที่ดีที่สุด
  - [ ] ผู้ตั้งกระทู้สามารถปิดการแสดงความเห็นได้
  - [ ] ผู้ใช้ สามารถตอบกระทู้ได้ กี่ครั้งก็ได้ (ตอบกระทู้ตัวเองก็ได้)
  - [ ] ผู้ใช้อื่นๆ สามารถโหวตให้คะแนนกระทู้ หรือความเห็นของคนอื่นได้
  - [ ] ผู้ใช้ที่เป็น  "staff" สามารถลบกระทู้หรือความเห็นใครก็ได้
  - [ ] ผู้ใช้สามารถอยู่ในกลุ่มได้มากกว่า 1 กลุ่ม

### Analytic & Design
จากคุณสมบัตดังกล่าว เราจะใช้ความรู้เรื่อง Normalization / Relation / ER Modeling เพื่อออกแบบฐานข้อมูลของเรา ซึ่งจะได้ออกมาดังนี้

![enter image description here](https://i.imgur.com/dj5j9My.png)

จาก ER Diagram เรามี model หรือ table 4 (+1) ตัวดังนี้
  - **group** เก็บข้อมูลกลุ่มผู้ใช้งาน (staff, member)
  - **user** เก็บข้อมูลผู้ใช้งาน และสัมพันธ์กับ **group** แบบ **many-to-many** ตาม feature ***"ผู้ใช้สามารถอยู่ในกลุ่มได้มากกว่า 1 กลุ่ม"***
  - **topic** เก็บกระทู้หรือคำถาม รวมทั้งเก็บความสัมพันธ์กับ **user** แบบ **many-to-one** คือ ***"- ผู้ใช้ตั้งกระทู้ถามปัญหา (Topic) ได้ไม่จำกัด"***
  - **comment** เก็บความเห็นหรือคำตอบ และเก็บความสัมพันธ์กับ **user** แบบ **many-to-one** และความสัมพันธ์กับ **topic** แบบ **many-to-one** ไว้ด้วย ตาม feature ***"- [ ] ผู้ใช้ สามารถตอบกระทู้ได้ กี่ครั้งก็ได้ (ตอบกระทู้ตัวเองก็ได้)"***

Diagram ของเราประกอบไปด้วยความสัมพันธ์ทั้งหมด 3 แบบคือ

  - **many-to-many** จากมุมมองของ **user <--> group**
  - **one-to-many** จากมุมมองของ **user -> topic** และ **user -> comment**
  - **many-to-one** จากมุมมองของ **topic -> user** และ **comment -> topic** และ **comment -> user**

> ในทางเทคนิก เราใช้ table **user_has_group** ที่สัมพันธ์กับ group แบบ many-to-one และสัมพันธ์กับ user แบบ many-to-one เช่นกัน มาเพื่อกำหนดความเป็น many-to-many ให้กับ user และ group

## Native SQL
## Active Record


# Chapter 3 : Doctrine2 ORM
### Introduce to ORM

ORM หรือ [Object Relational Mapping](https://en.wikipedia.org/wiki/Object-relational_mapping) จะเป็นเรื่องที่สมเหตุสมผลในระบบ OO (Object-Oriented) ความมุ่มหมายของ ORM คือจัดเก็บสถานะ (State) ของ Object ไว้ในหน่วยความจำระยะยาว (นอกเหนือไปจากขณะที่ Object ถูกประมวลผล) เช่น ไฟล์ หรือ ฐานข้อมูล เป็นต้น

ในการโปรแกรมมิ่งที่ทำงานกับระบบ UI เราจะคุ้นชินกับการเก็บสถานะของ Object ไว้ในหน่วยความจำชั่วคราว (Memory) ในขณะที่มันกำลังประมวลผล เช่น การเปลี่ยนสถานะของ Window จากขยายเต็มจอ (Maximize) ไปเป็นย่อให้เล็กสุด (Minimize) *"ในขณะที่มันกำลังประมวลผล ก็หมายถึงในขณะที่เรากำลังเปิดโปรแกรมนั้นๆ อยู่"* สถานะของ Object Window (Window.state = 'minimized' หรือ Window.minimized = true) จะถูกเก็บไว้ในหน่วยความจำ เพื่อความรวดเร็วในการใช้งาน (ย่อ/ขยาย window อย่างรวดเร็ว)

บางกรณีเราจะเห็นว่าสถานะของ window เช่น ขนาดหน้าจอ (ความกว้าง/สูง) แม้จะปิดโปรแกรมไปแล้ว เมื่อเปิดขึ้นมาใหม่ โปรแกรมจะจำสถานะความกว้างและความสูงนั้นไว้ ทำให้โปรแกรมเป็นมิตรกับผู้ใช้มากขึ้น และนั่นแสดงว่ามีการเก็บสถานะของ Object ไว้ในหน่วยความจำบางอย่างเช่น แคชไฟล์เป็นต้น

ทั้งนี้บางสภาพแวดล้อม ผู้เขียนโปรแกรมอาจไม่จำเป็นต้องทำสิ่งเหล่านั้น (เก็บแคชสถานะ) แต่เป็นความสามารถในระดับของ SDK หรือ Framework ต่างๆ ที่มีมาให้อยู่แล้ว

การโปรแกรมมิ่งด้วย OO ในส่วนของ UI ต่างๆ เป็นเรื่องที่ค่อนข้างตรงไปตรงมาและชัดเจนในเรื่อง Object และ state เพราะมักจะมีช่วงชีวิต (Life Cycle) อยู่ในขณะที่กำลังเปิดโปรแกรมอยู่ (Runtime)

เมื่อเราโปรแกรมมิ่งด้วย OO ในสถาปัตยกรรมที่ต่างออกไป เช่น Client/Server ช่วงชีวิตของโปรแกรมจะถูกแยกขาดออกเป็นสองส่วน (Client side และ Server side) และสถานะของ Object ที่เปลี่ยนไปจึงถูกแยกขาดออกจากกันโดยสิ้นเชิง (Stateless) และเพื่อทำให้สถานะของ Object ยังคงอยู่เมื่อมันถูกเปลี่ยนไป  (Statefull) ไม่ว่าจากฝั่งไหน เราจะต้องเก็บมันไว้ในหน่วยความจำบางอย่าง เช่น Cookie สำหรับการทำงานบน Browser หรือแม้กระทั้ง Database ในรูปของ table ที่ทำหน้าที่เป็นตัวแทนของ object ต่างๆ



#### Persistence

นึกภาพ Object Person เปลี่ยนสถานะจากอายุ 20 เป็น 21 ปี (ไม่ว่าโดยใครก็ตาม) มันจะถูก **"จัดเก็บ"** ไว้ใน table ที่เป็นตัวแทนของมัน (personal_table) ทำให้เมื่อมีใครก็ตามเรียกดูมันอีกครั้ง ก็จะได้สถานะที่เปลี่ยนไปแล้ว นานเท่าที่มันจะถูกเปลี่ยนอีกครั้ง

จากลักษณะเช่นนี้ เราลองนึกดูว่าหากเราออกแบบระบบและโปรแกรมด้วย OOP เต็มรูปแบบ (Fullstack OOP) จะดีแค่ไหนถ้าหากเราสามารถโพกัสงานของเราไปที่การเขียนโปรแกรมเฉพาะส่วนที่เป็นความต้องการของมันจริงๆ (Bussiness Logic) ส่วนหน้าที่ในการจัดเก็บสถานะของ Object ไม่ใช่หน้าที่ที่เราต้องไปยุ่งเกี่ยว (หรือยุ่งเกี่ยวน้อยที่สุด) เช่น เมื่อต้องการเก็บสถานะของ Person Object และ Object ที่เกี่ยวของเช่น Personal_Contact เราก็เพียงแต่เขียนมันตาม Concept ของ OO ธรรมดาๆ 

— ตัวอย่าง

เสร็จแล้วก็แค่โยนหน้าที่การจัดเก็บไปให้ใครซักคนเป็นคนทำ โดยที่เราไม่ต้องไปยุ่งเกี่ยวกับการจัดเก็บนั้นๆ (เชื่อมต่อฐานข้อมูล, ประกอบคำสั่ง SQL ฯลฯ)

ในทางกลับกัน เมื่อเราเรียกใช้งานมันใหม่ มันก็พร้อมใช้งานในรูปของ Object เดิมทันที!

​ทั้งหมดนี้เป็นแนวคิดของ ORM บทบทหน้าที่ของมันคือการแปลงโครงสร้างและความสัมพันธ์ของ Object รวมทั้งสถานะต่างๆ ไปยังหน่วยการจัดเก็บชนิดต่างๆ ไม่ว่าจะเป็น Relational Database หรือ noSQL Database ก็ตาม ทำให้การทำงานกับ ORM โดยส่วนมากเป็นเรื่องของการ "Mapping" หรือการทำแผนที่สำหรับการเปลี่ยน Data ลักษณะหนึ่งไปเป็นอีกลักษณะหนึ่ง (Convert) ในทางกลับกันเพื่อให้มันสามารถย้อนกลับ Data ที่ถูกเปลี่ยนไปแล้วกลับมาในรูปเดิมได้อีก (Revert)



#### The Object-Relational Impedance Mismatch

เมื่อต้องทำหน้าที่ในการเปลี่ยนโครงสร้างข้อมูลที่มีมุมมองต่างกันกลับไปกลับมา คือ Object-Relational ถูกนำเสนอในรูปของความสัมพันธ์ในแนวตั้ง (interconnected graph of objects) ส่วน Relational Database จะนำเสนอในรูปแบบความสัมพันธ์ในแนวนอน (tabular format) หรือที่เราคุ้นเคยคือ spreadsheet (โปรแกรม excel เป็นต้น) ORM จึงต้องทำหน้าที่ในการแก้ไขความไม่ลงลอยกันของระบบ (Impedance Mismatch) และเมื่อกล่าวเฉพาะ Object-Relational กับ Relational Database เราจะพบความไม่ลงลอยกันดังนี้



##### Granularity

โดยพื้นฐานแล้วจำนวนของ Objects และจำนวนของ Tables อาจไม่ได้มีเท่ากันเสมอไป

##### Subtypes (Inheritance)

การสืบทอดคุณสมบัติเป็นสิ่งพื้นฐานมากในโลกของ OO แต่เป็นเรื่อง (ที่โดยพื้นฐานแล้ว) ไม่ได้มีอยู่ในระบบของ Relational Database

##### Identity

Relational Database ใช้ Primary Key เป็นตัวแทนของ Data ในแต่ละ Record แต่ในโลกของ Object ตัวของมันเอง (instance) เป็นตัวแทนของมันอยู่แล้ว

##### Associations

Relational Database ใช้ foreign keys ในการสร้างความสัมพันธ์และความสันพันธ์ที่ว่าเป็นแบบสองทาง (bidirectional relationship) คือเราสามารถ Join ความสัมพันธ์จากฝั่ง (Table) ไหน เป็นตัวตั้งก็ได้ ส่วน Object-Relational จะเป็นความสัมพันธ์เพียงฝั่งเดียว (unidirectional) หากเราต้องการความสัมพันธ์สองฝั่ง เราจำเป็นต้องกำหนดใน Object ทั้งคู่ `user.getAddresses() <--> address.getUser()`

##### Data navigation

Object-Relational มีรูปแบบการเข้าถึงความพันธ์ต่างๆ แบบเป็นทอดๆ เช่น `user.getAddress().getCountry().getName()` แต่ใน Relational Database วิธีการที่มีประสิทธิภาพในการเข้าถึงข้อมูลที่สัมพันธ์กันคือใช้การ Join ข้อมูลมาในระนาบเดียวกันทั้งหมด



ทั้งหมดนี้เป็นสิ่งที่ ORM Library ทำในถายใน เพื่อให้เราสามารถเปลี่ยนรูปของโปรแกรมแบบหนึ่ง ไปเป็นอีกแบบ (paradigm matching) ได้



- What is Doctrine?
- Domain Model


Doctrine2 จะทำงานได้ดีในระบบที่ออกแบบด้วย OO ไม่เช่นนั้นมันอาจจะกลายเป็นเรื่อง "เข็นครกขึ้นภูเขา" ไปก็ได้ และเมื่อเราออกแบบระบบด้วย OO ขอแนะนำว่ามันควรจะมาจบลงที่ Domain Model Design

Domain Model Design ค่อนข้างเป็นเรื่องใหญ่ทีเดียว เราอาจจะต้องใช้เวลาและประสบการณ์ซักพักในการทำความเข้าใจมันอย่างถ่องแท้ ในที่นี้เราลองมาเริ่มต้นจากจุดเล็กๆ กันดู



**Domain** ในที่นี้จะหมายถึงปัญหา (problem) หรือภาระกิจที่เราต้องทำ (business) รวมทั้งสองความหมายนี้เข้าด้วยกัน ผมอยากจะให้มันหมายถึง "โจทย์" ที่เราต้องแก้ มาถึงจุดนี้ถ้าไม่มี Domain เราก็ไม่มีงานที่ต้องทำใช่ไหมครับ 

**Model** หมายถึงกรรมวิธีในการแก้ปัญหานั้น (solution) ในทางปฏิบัติ model คือแบบจำลองโครงสร้างการแก้ปัญหาที่ถูกจัดทำขึ้นอย่างมีระบบ

**Design** ก็หมายถึงวิธีปฏิบัติในการแก้ปัญหานั้นๆ ตามแบบที่เราได้วางไว้ ในระดับนี้การ design จะเป็นการอธิบายปัญหาและวิธีแก้ไขด้วยภาษาที่สามารถสื่อสารได้ง่าย เพื่อให้ทุกคนที่มีส่วนร่วมรับรู้และเข้าใจกันได้ดีที่สุด เช่น การใช้ UML หรือ Diagram ต่างๆ เข้ามาเป็นภาษากลางในการสื่อสาร (Ubiquitous Language)



"***An object model of the domain that incorporates both behavior and data. — แบบจำลองอ็อบเจ็คที่มีทั้งพฤติกรรมและข้อมูลอยู่ในตัวเดียวกัน***" เป็นนิยามจากหนังสือเรื่อง "Patterns of Enterprise Application Architecture" ของกูรูอย่าง ["Martin Fowler"](https://martinfowler.com/eaaCatalog/domainModel.html) นิยามนี้ค่อนข้างลงในรายละเอียดพอสมควร แต่ก็เป็นขอบเขตที่เหมาะกับการทำความเข้าใจควบคู่กับ Doctrine2 ทีเดียว



โดยสรุปแล้ว Domain Model เป็นการใช้โมเดลในการอธิบายปัญหาและวิธีแก้ในตัว ในระดับของการโปรแกรมแล้ว เราจะได้  Data Model ควบคู่ไปกับ Classs Model ที่ทำหน้าที่ทั้งทำหน้าที่เก็บข้อมูลและประมวลผลในตัวเอง



ถึงตรงนี้ Doctrine2 จะทำหน้าที่ Mapping คลาสโมเดล (ที่มี bussiness logic อยู่ในตัวเอง) เข้ากับ Data Storage ทั้งนี้เพื่อจำกัดขอบเขตของสิ่งที่เราต้องให้ความสำคัญ (Focus) ในการโปรแกรมจริงๆ ไว้ พูดง่ายๆคือ เมื่อเราออกแบบระบบตามกรรมวิธีของ Domain Model ไว้แล้ว สิ่งที่เราควรทำก็คือเขียนโปรแกรมตาม Model นั้น โดยไม่ต้องไปสนใจเรื่องอื่นๆ ที่ไม่ได้อยู่ในขอบเขต Model นั้นๆ เช่น เรื่องความแตกต่างในการจัดเก็บข้อมูลในฐานข้อมูลชนิดต่างๆ เป็นต้น



ตัวอย่าง



- Doctrine Core Concept
- Entity Definition
  - Mapping
  - Interitane
  - Abstraction
- Assocation
- Entity Management
  - Manager
  - Repository
- Life Cycle Events
- DQL
# Chapter 4 : Doctrine 2 in Depth
- Unit of Work
# Chapter 5 : Best Practice & Performance