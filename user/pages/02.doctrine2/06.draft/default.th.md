---
title: draft
published: true
---

http://www.mehdi-khalili.com/orm-anti-patterns-series


# Chapter 1 : Back to School

## Relational database 101
Database ถือเป็นหัวใจสำคัญขอบการสร้าง application จุดประสงค์หลักของ database ก็ตรงตัวตามชื่อของมัน คือเป็นฐานข้อมูล ทุกๆ application จะมีการเก็บข้อมูลอย่างใด อย่างหนึ่งเสมอ Relational database ก็เป็นหนึ่งในรูปแบบการเก็บข้อมูลที่ว่านั้น และตรงตามชื่อของมัน คือฐานข้อมูลเชิงสัมพันธ์

Doctrine ออกแบบมาเพื่อทำงานกับฐานข้อมูลหลายแบบ รวมทั้ง Relational Database ด้วย เมื่อทำงานกับ Doctrine เราแทบไม่ต้องแตะต้อง Database เลย สำหรับ Doctrine แล้ว Database ถูกมองเป็น Storage หรือพื้นที่สำหรับเก็บข้อมูลอย่างหนึ่ง แต่เพื่อให้ง่ายต่อการทำความเข้าใจการทำงานของ Doctrine เราควรรู้พื้นฐานของ Database แต่ละชนิดด้วย

Relational Database ถูกออกแบบมาเพื่อจัดการกับข้อมูลขนาดใหญ่ ความสามารถที่เด่นชัดของมันคือ ช่วยลดความซ้ำซ้อนของการจัดเก็บข้อมูลได้อย่างยอดเยี่ยม (แต่มันก็นำความปวดหัวมาสู่เราเหมือนกัน เมื่อต้องดึงข้อมูลที่ไม่ซ้ำซ้อนนั้นออกมาแสดง) ต้องยกนิ้วให้กับคนที่นำเสนอไอเดียนี้จริงๆ (1970, Edgar F. Codd) เพราะมันดูเรียบง่าย แต่เปี่ยมพลังมาก

### Foundational
พื้นฐานแนวคิดของ Relational Database ค่อนข้างเรียบง่าย เราแค่ต้องเรียนรู้เรื่องง่ายๆ 3 เรื่อง นั่นคือ

  1. **Column** คือ set ของข้อมูล (data) ที่เราต้องการเก็บ แบ่งออกเป็นหลายประเภท ตามชนิดข้อมูลทางคอมพิวเตอร์ เช่น String -- ชื่อคน, Integer -- อายุ เป็นต้น
  2. **Row** คือ Record หรือแถวข้อมูลที่ประกอบไปด้วยชุดข้อมูลของ Column
  3. **Table** คือ Collection หรือกลุ่มข้อมูลที่ประกอบไปด้วย Row ต่างๆ


เมื่ออธิบายด้วยภาพ เราจะได้รูปแบบนี้
![enter image description here](https://i.imgur.com/BmV1L1L.png)

การจัดเก็บข้อมูลก็เพียงแต่กำหนด Column ที่เราต้องการ และเก็บลงมาเรื่อยๆ ทีละ Row ตามแต่เราจะพอใจ หน้าตามันจะเหมือนกับ Excel Sheet ที่เราคุ้นเคย

---- TODO: ใส่ภาพตัวอย่างตารางข้อมูล

และนี่คือพื้นฐานการจัดเก็บข้อมูลสำหรับ Relational Database

### Relational
ความสัมพันธ์ ถือเป็นหัวใจสำคัญของ Relational Database เพราะเมื่อเก็บข้อมูลกันจริงๆ Relational Database จะแยกเก็บข้อมูลแต่ละอย่างออกจากกัน คือแยก table ออกจากกันเป็นเรื่องๆ เช่น คน, ประเทศ จะถูกจัดเก็บกันคนละ table ทั้งนี้เพื่อลดความซ้ำซ้อนของการจัดเก็บข้อมูลนั่นเอง

เทคนิกในการแยกประเภทข้อมูลเพื่อไม่ให้เกิดความซ้ำซ้อนใน Relational Database เรียกว่า Normalization แบ่งออกเป็น 5 ระดับ (1NF - 5NF) ในทางปฏิบัติเราใช้เทคนิกนี้เพียง 1NF - 3NF ก็พอสำหรับ application ทั่วๆ ไป

เรื่อง Normalization ถือเป็นเรื่องสำคัญที่เราต้องรู้ ถ้าหากเราต้องการเขียน app ขึ้นมาจริงๆ ซักตัว แต่เราจะว่ากันในหัวข้อถัดไปนะครับ

เอาล่ะครับ เมื่อข้อมูลไม่ซ้ำซ้อนกัน การอัปเดทข้อมูลของเราก็จะง่ายตามไปด้วย ลองนึกภาพว่า เรามีข้อมูลคน 100 คนใน 10 ประเทศ แปลว่าทุกๆ 10 คน จะเป็นคนประเทศเดียวกัน

ถ้าหากเราเก็บข้อมูลทั้งหมดไว้ใน table เดียวกัน และถ้าเขียนชื่อประเทศผิดซักประเทศ เราอาจต้องตามแก้ข้อมูลถึง 10 rows ก็เป็นได้

---- TODO: insert data sample

ทางออกคือแยกเก็บคน และเก็บประเทศออกจากกัน และทำการ link เข้าหากันด้วย key ตามวิธีของ Normalization

---- TODO: insert data sample

ถึงตรงนี้ มีสิ่งที่เราต้องเรียนรู้เพิ่มอีก 3 อย่าง เพื่อใช้ออกแบบ database ของเราให้มีความสัมพันธ์กัน

#### 1. Primary Key
คือ ค่าของข้อมูลใน column ที่ใช้กำหนดความเป็นหนึ่งเดียว (uniquely) ของแต่ละแถวข้อมูล คล้ายกับหมายเลขบัตรประชาชน ที่แต่ละคนจะมีไม่ซ้ำกัน

Primary Key อาจเป็นค่าของ column เดียว หรือหลาย column รวมกัน ก็ได้ และถ้ามันมาจากหลาย column รวมกัน เราจะเรียกมันว่า `Composite Key` หรือคีย์ร่วม

--- TODO: insert data sample

Composite Key คือการใช้ค่าของหลาย column รวมกัน เพื่อให้เกิดความเป็นหนึ่งเดียว (uniquely) ของแถวข้อมูล เช่น หากเราไม่ใช้บัตรประชาชนเป็นตัวกำหนดความเป็นหนึ่งเดียวของคน เราอาจใช้ ชื่อ และนามสกุล เป็นตัวกำหนดก็ได้ (แต่ในความเป็นจริงชื่อและนามสกุลอาจซ้ำกันได้)

--- TODO: insert data sample

ในระบบสมัยใหม่ ไม่นิยมใช้ Composite Key เพื่อเป็นตัวแทนของข้อมูลจำเพาะมากนัก โดยส่วนมากจะใช้เพื่อเชื่อมเข้ามูลใน direction ที่เรียก่า many-to-many 

Primary Key นิยมใช้ ตัวเลขลำดับ 1-n เป็นส่วนมาก เนื่องจากมีความสะดวก และไม่จำเป็นต้องเป็นที่จดจำของคน แต่หากเราต้องการ Key ที่มีความหมายและง่ายสำหรับการจดจำ หรือในทางกลับกันคือ ยากสำหรับการคาดเดา เราก็อาจสร้างชุดรหัสที่ไม่ซ้ำกันมาเป็น primary key แทนก็ได้

#### 2. Foreign Key
Foreign Key ก็คือ Primary Key ที่ถูกใช้ในการอ้างอิงถึงแถวข้อมูล (row) ในต่าง table เมื่อเราทำการ link หรือทำความสัมพันธ์ของข้อมูล

--- TODO: insert data sample

#### 3. Cardinality
Cardinality คือลักษณะเฉพาะของสัมพันธ์ในระบบ RDB ส่วนนี้สำคัญมากในการทำความเข้าใจวิธีคิดของ  Doctrine เราจะได้เรียนรู้ Direction ต่างๆ ของสัมพันธ์ของข้อมูลตลอดทั้งเล่มของหนังสือนี้

อย่างที่เราทราบ RDB ใช้ระบบ Key เป็นตัวอ้างอิงเพื่อสร้างความสัมพันธ์ของข้อมูลในรูปแบบต่างๆ Primary Key ใช้เป็นตัวแทนของแต่ละ Row และเมื่อมันถูกใช้เป็นตัวอ้างอิงใน table อื่น เราจะเรียกมันว่า Foreign Key โดยพื้นฐานแล้วลักษณะความสัมพันธ์ใน RDB แบ่งออกเป็น 3(+1) แบบคือ

##### ***One-to-One** ความสัมพันธ์แบบ หนึ่งต่อหนึ่ง (1:1)*

![enter image description here](https://i.imgur.com/K24nHV0.png)

ความสัมพันธ์ของข้อมูลแบบหนึ่งต่อหนึ่ง เช่น **"ประเทศ 1 ประเทศ มีเมืองหลวงเพียงแห่งเดียว ในทางกลับกัน เมืองหลวง 1 เมือง ก็เป็นของประเทศได้เพียงประเทศเดียว"**

ในทางปฏิบัติสถานการณ์ที่เข้าลักษณะ one-to-one แบบสมจริงนั้นมีไม่มากนัก แต่ one-to-one ก็มีประโยชน์ในลักษณะของการใช้เชื่อมข้อมูลที่เป็นตัวเลือก (Optional) ของระบบ หรือการเพิ่มคุณสมบัติของระบบในภายหลัง (อาจถอดเข้าถอดออกได้) เช่น การเก็บข้อมูลเฉพาะด้านของพนักงานแต่ละคน เราอาจไม่ต้องรวมทุกอย่างไว้ในตารางของ "พนักงาน - employee" ก็ได้ เราสามารถแยกกลุ่มข้อมูลออกเป็นส่วนๆ และเชื่อมความสัมพันธ์กันแบบ one-to-one เช่น ข้อมูลสุขภาพ (employee-medical), ข้อมูลภูมิลำนำ (employee-local) เป็นต้น

##### ***One-to-Many** หรือ หนึ่งต่อมาก (1:n) ....*
##### ***Many-to-Many** หรือ มากต่อมาก (n:n)*

![enter image description here](https://i.imgur.com/NVux8Bf.png)

![enter image description here](https://i.imgur.com/0l5YFkP.jpg)

##### ***Many-to-One** หรือ มากต่อหนึ่ง (n:1) ....* inverse of 1:n

### Normalization
https://www.guru99.com/database-normalization.html

### ER Modeling
https://www.guru99.com/er-modeling.html

## SQL 101

จากหัวข้อที่ผ่านมาเราได้เรียนรู้เกี่ยวกับวิธีคิดในการเก็บข้อมูลของ RDB หัวข้อนี้เราจะได้เรียนรู้วิธีการบริหารจัดการข้อมูลใน RDB ในที่นี้เราจะเรียนรู้เพียงการบริหารจัดการข้อมูลแบบเบื้องต้นคือ

  - Read การดูข้อมูลในรูปแบบต่าง
  - Create การเพิ่มรายการใหม่
  - Update การแก้ไขข้อมูลเดิม
  - Delete การลบข้อมูลทิ้ง

การบริหารจัดการข้อมูลใน RDB โดยพื้นฐานใช้ภาษาคอมพิวเตอร์ง่ายๆ ที่เรียกว่า SQL (Structured Query Language) เป็นภาษาโคลงสร้างที่ไม่ซับซ้อน ไม่เน้นการคำนวณ (Calculate logic) ในตัวภาษาเอง เป็นเพียงประโยคคำสั่งที่ตรงไปตรงมา ทำให้มันง่ายต่อการจดจำ และการใช้งานมากๆ

### How Is Data Organized in a Relational Database?
เพื่อให้ใช้ SQL ได้เร็วขึ้น เราลองมาดูรูปแบบการเก็บข้อมูลใน RDB กันก่อน ดังที่เราได้เรียนรู้มาแล้วว่า RDB เก็บข้อมูลในรูปแบบ "ตาราง" ซึ่งอันที่จริงในทางคอมพิวเตอร์มันคือการเก็บข้อมูลในรูปแบบ "two-dimensional array" หรือทางคณิตศาสตร์ คือ "two-dimensional matrix" เรียกง่ายๆ ง่า "อาเรย์สองมิติ"

#### Two-dimensional Matrix

![two-dimensional matrix](https://i.imgur.com/zDTfyKV.gif)

นี่คือรูปแบบ Matrix 2 มิติ ดูไม่ซับซ้อนเลยใช่ไหมครับ อธิบายง่ายๆ คือ ในแต่ละวงเว็บ ตัวเลขแรกคือลำดับของแถวข้อมูล ตัวเลขที่สองคือลำดับคอลัมน์ -- (row, column) แค่นี้เองครับ

#### Two-dimensional Arrays in C-based
ส่วนในระบบคอมพิวเตอร์ Array 2 มิติในภาษาคอมพิวเตอร์ที่มีพื้นมาจากภาษาซี (C-based) มีรูปแบบดังนี้

![enter image description here](https://i.imgur.com/5kCifUW.jpg)

ดูแล้วก็ไม่มีอะไรซับซ้อนเกินไปใช่ไหมครับ เพียงแค่ภาษา C-based จะนับลำดับเริ่มต้นของ array จาก `0-n` 

สิ่งที่เราต้องเรียนรู้ต่อไปก็ไม่ใช่เรื่องยากแล้ว มันไม่ใช่เกมส์ไล่จับหนูที่ไม่มีทิศทาง การเข้าถึงตำแหน่งของข้อมูลใน RDB ค่อนข้างตรงไปตรงมา มันก็แค่ ***"คอลัมน์ไหน แถวที่เท่าไหร่?"*** หรือ ***"แถวที่คอลัมน์มีค่าเท่ากับ x"***  แค่นั้นเอง!

### Example Data
ทีนี้เรามาลองบริหารจัดการข้อมูลในระบบ RDB กันดูเลยดีกว่านะครับ และเพื่อให้เห็นภาพชัดขึ้น ผมจะจำลองข้อมูลง่ายๆ ขึ้นมา เอาเป็นชื่อว่า *"การบริหารจัดการ**ผู้ใช้งาน**และ**กลุ่ม**"* นะครับ

#### ER Modeling

![enter image description here](https://i.imgur.com/uP6tXmQ.png)

โมเดลตัวอย่างของเรามีแค่ 2 ตาราง และมีควาสัมพันธ์กันอยู่ในแบบ **One-to-many (1:M)** หรือาจจะพูดได้ว่า

	- **1:M** ถ้ามองจากมุมของ **user -> group** คือ *"ผู้ใช้ 1 คนอยู่ในกลุ่มได้ 1 กลุ่ม"*
	- **M:1** ถ้ามองจากมุมมองของ **group -> user** คือ *"มีผู้ใช้หลายคน (หรืออาจจะไม่มี) อยู่ในแต่ละกลุ่ม"*

#### ER Data Dictionary
##### - Group : กลุ่มผู้ใช้งาน

| Column 	| Type    	| Key 	| Note        	|
|--------	|---------	|-----	|-------------	|
| id     	| INT     	| PK  	| Primary Key 	|
| name   	| VARCHAR 	|     	| ชื่อกลุ่มผู้ใช้    	|


##### - User : ผู้ใช้งาน

| Column     	| Type     	| Key 	| Note                  	|
|------------	|----------	|-----	|-----------------------	|
| id         	| INT      	| PK  	| Primary Key           	|
| group_id   	| INT      	| FK  	| Foreign Key ของ group 	|
| username   	| VARCHAR  	|     	| ชื่อผู้ใช้งาน              	|
| password   	| VARCHAR  	|     	| รหัสผ่าน                	|
| email      	| VARCHAR  	|     	| อีเมล์                  	|
| created_at 	| DATETIME 	|     	| วันที่เพิ่มรายการ          	|


### Basic SQL

#### Select
#### Insert
#### Update
#### Delete
#### Union
#### Join
#### Condition
#### Where
#### Having
#### Group
#### Order
#### Limit
#### Join-Conditional
#### Sub Query

## ORM 101

# Chapter 2 : Basic ORM

## Simple Forum Software

ก่อนจะเข้าเนื้อหาของ Doctrine น่าจะเป็นเรื่องที่ดีมาก ถ้าเราจะมาลองเคาะสนิมกันด้วยบทเรียนเก่าๆ เพื่อให้เห็นวิธีการและวิธีคิดที่ต่างกัน ลองมาทำระบบเว็บบอร์ดหรือ forum ง่ายๆ กันดูนะครับ

เราจะใช้ความรู้และเทคนิกจากบทที่แล้ว สำหรับสร้างเว็บบอร์ดนี้ขึ้นมา ก่อนอื่น เรามากำหนด feature คร่าวๆ กันก่อนครับ

### Features
  - [ ] ผู้ใช้ (User) ตั้งกระทู้ถามปัญหา (Topic) ได้ไม่จำกัด
  - [ ] ผู้ตั้งกระทู้สามารถเลือกความเห็น (Comment) 1 ความเห็นว่าเป็นคำตอบที่ดีที่สุด
  - [ ] ผู้ตั้งกระทู้สามารถปิดการแสดงความเห็นได้
  - [ ] ผู้ใช้ สามารถตอบกระทู้ได้ กี่ครั้งก็ได้ (ตอบกระทู้ตัวเองก็ได้)
  - [ ] ผู้ใช้อื่นๆ สามารถโหวตให้คะแนนกระทู้ หรือความเห็นของคนอื่นได้
  - [ ] ผู้ใช้ที่เป็น  "staff" สามารถลบกระทู้หรือความเห็นใครก็ได้
  - [ ] ผู้ใช้สามารถอยู่ในกลุ่มได้มากกว่า 1 กลุ่ม

### Analytic & Design
จากคุณสมบัตดังกล่าว เราจะใช้ความรู้เรื่อง Normalization / Relation / ER Modeling เพื่อออกแบบฐานข้อมูลของเรา ซึ่งจะได้ออกมาดังนี้

![enter image description here](https://i.imgur.com/dj5j9My.png)

จาก ER Diagram เรามี model หรือ table 4 (+1) ตัวดังนี้
  - **group** เก็บข้อมูลกลุ่มผู้ใช้งาน (staff, member)
  - **user** เก็บข้อมูลผู้ใช้งาน และสัมพันธ์กับ **group** แบบ **many-to-many** ตาม feature ***"ผู้ใช้สามารถอยู่ในกลุ่มได้มากกว่า 1 กลุ่ม"***
  - **topic** เก็บกระทู้หรือคำถาม รวมทั้งเก็บความสัมพันธ์กับ **user** แบบ **many-to-one** คือ ***"- ผู้ใช้ตั้งกระทู้ถามปัญหา (Topic) ได้ไม่จำกัด"***
  - **comment** เก็บความเห็นหรือคำตอบ และเก็บความสัมพันธ์กับ **user** แบบ **many-to-one** และความสัมพันธ์กับ **topic** แบบ **many-to-one** ไว้ด้วย ตาม feature ***"- [ ] ผู้ใช้ สามารถตอบกระทู้ได้ กี่ครั้งก็ได้ (ตอบกระทู้ตัวเองก็ได้)"***

Diagram ของเราประกอบไปด้วยความสัมพันธ์ทั้งหมด 3 แบบคือ

  - **many-to-many** จากมุมมองของ **user <--> group**
  - **one-to-many** จากมุมมองของ **user -> topic** และ **user -> comment**
  - **many-to-one** จากมุมมองของ **topic -> user** และ **comment -> topic** และ **comment -> user**

> ในทางเทคนิก เราใช้ table **user_has_group** ที่สัมพันธ์กับ group แบบ many-to-one และสัมพันธ์กับ user แบบ many-to-one เช่นกัน มาเพื่อกำหนดความเป็น many-to-many ให้กับ user และ group

## Native SQL
## Active Record


# Chapter 3 : Doctrine2 ORM
- introduce to ORM
# Chapter 4 : Doctrine 2 in Depth
- Unit of Work
# Chapter 5 : Best Practice & Performance